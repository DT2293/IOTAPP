import 'dart:convert';
import 'package:dio/dio.dart';
import 'package:easy_localization/easy_localization.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:dart_jsonwebtoken/dart_jsonwebtoken.dart';

class AuthService {
 // final Dio _dio = Dio(BaseOptions(baseUrl: 'http://dungtc.iothings.vn/api/auth'));
 final Dio _dio =
     Dio(BaseOptions(baseUrl: 'http://192.168.1.3:3000/api/auth'));

  Future<String?> login(String usernameOrEmail, String password) async {
    try {
      Response response = await _dio.post('/login', data: {
        "username": usernameOrEmail,
        "email": usernameOrEmail,
        "password": password,
      });

      if (response.statusCode == 200) {
        SharedPreferences prefs = await SharedPreferences.getInstance();
        String token = response.data['token'];
        await prefs.setString('token', token);
        await prefs.setString('user', jsonEncode(response.data['user']));
        return null;
      } else {
        return response.data['error'] ?? tr('login_failed');
      }
    } on DioException catch (e) {
      if (e.response != null) {
        return e.response?.data['error'] ?? tr('server_error');
      }
      return tr('network_error');
    } catch (e) {
      return tr('unknown_error');
    }
  }

  Future<String?> sendOtp(String email) async {
    try {
      Response response = await _dio.post('/forgot-password', data: {
        "email": email,
      });

      if (response.statusCode == 200) {
        return null;
      } else {
        return response.data['error'] ?? tr('otp_send_failed');
      }
    } on DioException catch (e) {
      if (e.response != null) {
        return e.response?.data['error'] ?? tr('server_error');
      }
      return tr('network_error');
    } catch (e) {
      return tr('unknown_error');
    }
  }

  Future<Map<String, dynamic>?> verifyOtp(String email, String otp) async {
    try {
      Response response = await _dio.post('/verify-otp', data: {
        "email": email,
        "otp": otp,
      });

      if (response.statusCode == 200) {
        return response.data;
      } else {
        throw Exception(response.data['error'] ?? tr('otp_invalid'));
      }
    } on DioException catch (e) {
      throw Exception(e.response?.data['error'] ?? tr('otp_invalid'));
    } catch (e) {
      throw Exception(tr('unknown_error'));
    }
  }


  Future<String?> resetPassword(String email, String newPassword) async {
    try {
      final response = await _dio.post('/reset-password', data: {
        'email': email,
        'newPassword': newPassword,
      });
      return null;
    } catch (e) {
      return _handleError(e);
    }
  }

  String _handleError(Object error) {
  if (error is DioException) {
    final data = error.response?.data;

    if (data is Map<String, dynamic>) {
      return data['message'] ?? error.message ?? "ƒê√£ x·∫£y ra l·ªói kh√¥ng x√°c ƒë·ªãnh";
    } else if (data is String) {
      return data;
    }

    return error.message ?? "ƒê√£ x·∫£y ra l·ªói kh√¥ng x√°c ƒë·ªãnh";
  }

  return "ƒê√£ x·∫£y ra l·ªói kh√¥ng x√°c ƒë·ªãnh";
}


  Future<String?> updatePassword(
      String oldPassword, String newPassword, int userId, String token) async {
    try {
      final response = await _dio.put(
        '/updatepassword/$userId',
        data: {
          "oldPassword": oldPassword,
          "newPassword": newPassword,
        },
        options: Options(
          headers: {
            "Authorization": "Bearer $token",
          },
        ),
      );

      if (response.statusCode == 200) {
        print("‚úÖ ƒê·ªïi m·∫≠t kh·∫©u th√†nh c√¥ng: ${response.data['message']}");
        return null; // null nghƒ©a l√† th√†nh c√¥ng
      } else {
        return response.data['error'] ?? "L·ªói khi ƒë·ªïi m·∫≠t kh·∫©u!";
      }
    } on DioException catch (e) {
      if (e.response != null) {
        return e.response?.data["error"] ?? "L·ªói t·ª´ server!";
      }
      return "L·ªói k·∫øt n·ªëi m·∫°ng!";
    } catch (e) {
      return "L·ªói kh√¥ng x√°c ƒë·ªãnh: $e";
    }
  }

  Future<String?> register(
      String username, String email, String password) async {
    try {
      final response = await _dio.post(
        '/register',
        data: {
          "username": username,
          "email": email,
          "password": password,
        },
        options: Options(headers: {"Content-Type": "application/json"}),
      );

      if (response.statusCode == 201) {
        return null; // Th√†nh c√¥ng, kh√¥ng c√≥ l·ªói
      } else {
        // Tr·∫£ v·ªÅ th√¥ng b√°o l·ªói n·∫øu c√≥
        return response.data["error"] ?? "ƒêƒÉng k√Ω th·∫•t b·∫°i!";
      }
    } on DioException catch (e) {
      if (e.response != null) {
        // Tr·∫£ v·ªÅ th√¥ng b√°o l·ªói chi ti·∫øt t·ª´ server n·∫øu c√≥
        return e.response?.data["error"] ?? "ƒêƒÉng k√Ω th·∫•t b·∫°i!";
      }
      // Tr·∫£ v·ªÅ l·ªói khi k·∫øt n·ªëi ho·∫∑c l·ªói kh√¥ng x√°c ƒë·ªãnh
      return "L·ªói k·∫øt n·ªëi: ${e.message}";
    } catch (e) {
      // Tr·∫£ v·ªÅ l·ªói kh√¥ng x√°c ƒë·ªãnh
      return "L·ªói kh√¥ng x√°c ƒë·ªãnh: $e";
    }
  }

  Future<bool> updateUser(String username, String email, String token) async {
    int? userId = await getUserId(); // üîç L·∫•y userId t·ª´ SharedPreferences

    if (userId == null) {
      print("üö® Kh√¥ng t√¨m th·∫•y userId!");
      return false;
    }

    try {
      print("üîë Token: $token");
      print("üìå userId: ${userId.toString()}");

      final response = await _dio.put(
        '/update/$userId',
        data: {
          "username": username,
          "email": email,
        },
        options: Options(
          headers: {
            "Content-Type": "application/json",
            "Authorization": "Bearer $token",
          },
        ),
      );

      print("Response Status: ${response.statusCode}");
      print("Response Data: ${response.data}");

      return response.statusCode == 200;
    } on DioException catch (e) {
      print("üö® L·ªói update user: ${e.response?.data ?? e.message}");
      return false;
    }
  }

  Future<int?> getUserId() async {
    SharedPreferences prefs = await SharedPreferences.getInstance();

    String? token = prefs.getString('token'); // L·∫•y token t·ª´ SharedPreferences
    if (token == null) {
      print("üö® Kh√¥ng t√¨m th·∫•y token!");
      return null;
    }

    try {
      final jwt = JWT.decode(token);
      int? userId = jwt.payload['userId'] as int?; // L·∫•y userId ki·ªÉu int
      print("üìå userId t·ª´ token: $userId");
      return userId;
    } catch (e) {
      print("üö® L·ªói decode JWT: $e");
      return null;
    }
  }

  Future<String?> getToken() async {
    SharedPreferences prefs = await SharedPreferences.getInstance();
    return prefs.getString('token');
  }

  Future<Map<String, dynamic>?> getUserInfo() async {
    SharedPreferences prefs = await SharedPreferences.getInstance();
    String? userData = prefs.getString('user');

    print(
        "Stored user data: $userData"); // ‚úÖ Debug xem d·ªØ li·ªáu c√≥ l∆∞u ƒë√∫ng kh√¥ng

    if (userData != null) {
      return jsonDecode(userData);
    }
    return null;
  }

  Future<List<String>> getUserDevices() async {
    SharedPreferences prefs = await SharedPreferences.getInstance();
    String? userData = prefs.getString('user');

    if (userData != null) {
      Map<String, dynamic> userMap = jsonDecode(userData);
      List<String> devices = List<String>.from(userMap['devices'] ?? []);
      print("User devices: $devices"); // ‚úÖ Debug danh s√°ch thi·∫øt b·ªã
      return devices;
    }
    return [];
  }

  Future<void> logout() async {
    SharedPreferences prefs = await SharedPreferences.getInstance();
    await prefs.remove('token');
    await prefs.remove('user');
  }
}


//  final Dio _dio = Dio(BaseOptions(baseUrl: 'http://dungtc.iothings.vn/api/auth'));
 //  String? userId = await getUserId();
// Future<String?> login(String usernameOrEmail, String password) async {
//     try {
//       // G·ª≠i request ƒë·∫øn API v·ªõi c·∫£ username ho·∫∑c email
//       Response response = await _dio.post('/login', data: {
//         "username": usernameOrEmail,
//         "email": usernameOrEmail,
//         "password": password,
//       });

//       if (response.statusCode == 200) {
//         // L∆∞u th√¥ng tin ng∆∞·ªùi d√πng v√† token v√†o SharedPreferences
//         SharedPreferences prefs = await SharedPreferences.getInstance();
//         String token = response.data['token'];
//         await prefs.setString('token', token);
//         await prefs.setString('user', jsonEncode(response.data['user']));

//         return null;  // Tr·∫£ v·ªÅ null n·∫øu ƒëƒÉng nh·∫≠p th√†nh c√¥ng
//       } else {
//         return response.data['error'] ?? 'ƒêƒÉng nh·∫≠p th·∫•t b·∫°i!';
//       }
//     } on DioException catch (e) {
//       // N·∫øu c√≥ l·ªói t·ª´ server ho·∫∑c API
//       if (e.response != null) {
//         return e.response?.data["error"] ?? "L·ªói khi k·∫øt n·ªëi t·ªõi server!";
//       }
//       return "L·ªói k·∫øt n·ªëi m·∫°ng!";
//     } catch (e) {
//       return "L·ªói kh√¥ng x√°c ƒë·ªãnh: $e";
//     }
//   }